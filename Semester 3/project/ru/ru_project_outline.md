# **Сольный проект: MicroPKI — Реализация PKI в одиночку**

## **Обзор проекта**
Вы создадите минимальную, но законченную PKI-систему, демонстрирующую все основные концепции. Основной упор делается на **корректность, а не полноту** — реализацию важнейших компонентов с применением надлежащей криптографии вместо создания функций корпоративного уровня.

### **Рекомендуемый стек технологий:**
- **Язык:** Python (библиотека `cryptography`) или Go (crypto/x509)
- **Хранилище:** SQLite для простоты
- **Интерфейс:** только CLI (веб-интерфейс не требуется)
- **Криптография:** используйте готовые библиотеки (не реализуйте криптографию самостоятельно!)

---

## **Скорректированный план на 8 недель**

### **Этап 1: Фундамент и корневой ЦС** *(Недели 1–2)*
**Цель:** Создать доверенный центр сертификации и базовую структуру.

**Результаты:**
1. **Настройка корневого ЦС:**
   - Сгенерировать самоподписанный сертификат корневого ЦС (RSA 4096 бит или ECC P-384)
   - Реализовать безопасное хранение закрытого ключа (зашифрованный файл с парольной фразой)
   - Сформулировать базовый документ политики сертификации (текстовый файл)

2. **Структура проекта:**
   - Создать организованную кодовую базу с модулями: `ca.py`, `certificates.py`, `crypto_utils.py`
   - Реализовать вспомогательные функции для преобразования PEM/DER
   - Настроить базовое логирование для аудита

3. **Тестирование:** Сгенерировать и проверить собственный сертификат корневого ЦС

**Ключевой аспект:** Понимание самоподписанных сертификатов и безопасного управления ключами.

---

### **Этап 2: Промежуточный ЦС и шаблоны сертификатов** *(Недели 3–4)*
**Цель:** Создать выпускающий ЦС и систему генерации сертификатов.

**Результаты:**
1. **Промежуточный ЦС:**
   - Сгенерировать запрос на сертификат (CSR) для промежуточного ЦС, подписать его корневым ЦС
   - Реализовать соответствующие ограничения длины пути (path length constraints)
   - Разграничить хранение ключей корневого и промежуточного ЦС

2. **Шаблоны сертификатов:**
   - Создать шаблоны для: `сервер`, `клиент`, `подпись кода`
   - Реализовать конструктор расширений (Basic Constraints, Key Usage, Extended Key Usage)
   - Добавить поддержку альтернативных имён субъекта (SAN)

3. **Тестирование:** Выпустить сертификат сервера от промежуточного ЦС, проверить цепочку

**Ключевой аспект:** Построение цепочек сертификатов и расширения X.509.

---

### **Этап 3: Управление сертификатами и репозиторий** *(Недели 5–6)*
**Цель:** Создать систему управления жизненным циклом сертификатов и их хранения.

**Результаты:**
1. **База данных сертификатов:**
   - Схема SQLite для выпущенных сертификатов (серийный номер, субъект, статус, даты выдачи/окончания)
   - Функции для сохранения, получения и обновления сертификатов
   - Генератор уникальных серийных номеров (последовательный со случайным компонентом)

2. **Базовый репозиторий:**
   - Простой HTTP-сервер для выдачи сертификатов через REST API (Flask/FastAPI)
   - Эндпоинты: `/certificate/<serial>` (GET), `/ca/<level>` (GET)
   - Точка распространения CRL (`/crl`)

3. **Тестирование:** Сохранить 5+ сертификатов, получить через API, проверить целостность

**Ключевой аспект:** Схемы хранения и получения сертификатов.

---

### **Этап 4: Система отзыва (CRL)** *(Недели 7–8)*
**Цель:** Реализовать генерацию и распространение списков отозванных сертификатов.

**Результаты:**
1. **Генератор CRL:**
   - Реализовать CRLv2 согласно RFC 5280
   - Поддержка причин отзыва (keyCompromise, CACompromise и др.)
   - Периодическая регенерация CRL (имитация с помощью команды)

2. **API отзыва:**
   - CLI-команда для отзыва сертификатов: `revoke <serial> --reason <причина>`
   - Обновление статуса сертификата в базе данных
   - Расчёт даты следующего обновления (next update)

3. **Распространение CRL:**
   - Расширить HTTP-сервер эндпоинтом `/crl`
   - Предоставлять CRL как корневого, так и промежуточного ЦС
   - Корректные заголовки Content-Type (`application/pkix-crl`)

4. **Тестирование:** Цикл «Выпуск → Отзыв → Генерация CRL → Проверка CRL»

**Ключевой аспект:** Механизмы отзыва и формат CRL.

---

### **Этап 5: OCSP-ответчик** *(Недели 9–10)*
**Цель:** Создать систему проверки статуса сертификатов в реальном времени.

**Результаты:**
1. **Базовый OCSP-ответчик:**
   - Реализовать разбор OCSP-запроса (RFC 6960)
   - Поддержка базового запроса: хеш издателя, серийный номер
   - Формирование ответа со статусом: good, revoked, unknown

2. **Сертификат для подписи OCSP:**
   - Выпустить специальный сертификат для подписи OCSP от промежуточного ЦС
   - Корректное расширение Extended Key Usage (`id-kp-OCSPSigning`)

3. **Интеграция:**
   - Добавить OCSP-эндпоинт к HTTP-серверу: `/ocsp` (POST)
   - Поддержка nonce для защиты от повторов
   - Кэширование последних ответов для повышения производительности

4. **Тестирование:** Создать OCSP-клиент, отправляющий запросы к вашему ответчику

**Ключевой аспект:** Протокол проверки статуса в реальном времени и специализированные сертификаты.

---

### **Этап 6: Проверка цепочки и клиентские инструменты** *(Недели 11–12)*
**Цель:** Создать инструменты проверки для использования вашей PKI.

**Результаты:**
1. **Механизм проверки цепочки:**
   - Реализовать упрощённую проверку пути согласно RFC 5280
   - Проверять: корректность подписи, срок действия, key usage, basic constraints
   - Построение цепочки от конечного сертификата до доверенного корневого

2. **Проверка статуса отзыва:**
   - Реализовать проверку CRL в валидаторе
   - Реализовать проверку OCSP в валидаторе
   - Логика приоритетов (сначала OCSP, затем CRL)

3. **Клиентская CLI-утилита:**
   - `micropki-client request-cert` — генерация CSR и отправка запроса
   - `micropki-client validate <cert>` — полная проверка цепочки
   - `micropki-client check-status <cert>` — проверка статуса отзыва

4. **Тестирование:** Полная проверка выпущенных сертификатов в различных состояниях

**Ключевой аспект:** Логика проверки сертификатов и инструменты на стороне клиента.

---

### **Этап 7: Усиление безопасности и аудит** *(Недели 13–14)*
**Цель:** Добавить функции безопасности и мониторинга.

**Результаты:**
1. **Система аудита:**
   - Подробное логирование всех операций в формате JSON
   - Криптографическая целостность журнала (хеш-цепочка записей)
   - Инструмент для запросов к журналам аудита

2. **Средства контроля безопасности:**
   - Ограничение частоты запросов на сертификаты (имитация)
   - Журнал прозрачности сертификатов (простой дополняемый текстовый файл с хешами)
   - Обнаружение компрометации закрытого ключа (имитация через «флаг компрометации»)

3. **Принудительное применение политик:**
   - Обеспечение минимальных размеров ключей (RSA ≥ 2048, ECC ≥ P-256)
   - Максимальные сроки действия сертификатов (Корневой: 10 лет, Промежуточный: 5 лет, Конечный: 1 год)
   - Валидация SAN (отсутствие wildcard-ов в критических системах)

4. **Тестирование:** Попытаться нарушить политики, убедиться, что это блокируется и логируется

**Ключевой аспект:** Эксплуатационная безопасность и принудительное применение политик.

---

### **Этап 8: Интеграция и демонстрационный сценарий** *(Недели 15–16)*
**Цель:** Создать полноценную демонстрацию работы вашей PKI.

**Результаты:**
1. **Демонстрационный скрипт:**
   - Скрипт на Python, выполняющий полный PKI-сценарий:
     1. Запуск корневого и промежуточного ЦС
     2. Выпуск сертификатов сервера, клиента и OCSP-ответчика
     3. Настройка отзыва
     4. Демонстрация успешной и неуспешной валидации

2. **Интеграция с TLS:**
   - Настроить простой веб-сервер (nginx или встроенный HTTP-сервер Python) с выпущенным сертификатом
   - Продемонстрировать TLS-соединение с пользовательским набором доверенных ЦС
   - Показать OCSP-стаплинг (имитированный или реальный)

3. **Демонстрация подписи кода:**
   - Подписать простой скрипт сертификатом для подписи кода
   - Проверить подпись с помощью ваших PKI-инструментов

4. **Итоговая документация:**
   - README с инструкцией по установке
   - Диаграмма архитектуры вашей реализации
   - Аспекты безопасности и ограничения
   - Полная справка по API/CLI

5. **Набор тестов:**
   - Комплексный набор тестов pytest, покрывающий все основные функции
   - Тесты граничных случаев (просроченные сертификаты, неверное key usage и т.д.)
   - Тест производительности с 1000 сертификатов (генерация, проверка)

**Ключевой аспект:** Интеграционное тестирование и реальное применение.

---

## **Критерии оценки для сольного проекта:**
1. **Корректность (35%):** Криптографические операции выполняются правильно
2. **Полнота (25%):** Достигнуты все 8 этапов с рабочим кодом
3. **Качество кода (20%):** Чистый, документированный, модульный код
4. **Безопасность (15%):** Корректное управление ключами, логика проверки
5. **Документация (5%):** Понятный README и встроенные комментарии

## **Советы для успешной реализации:**
1. **Начинайте с библиотек:** Используйте `cryptography` (Python) или стандартную библиотеку (Go) — не реализуйте криптографические примитивы самостоятельно
2. **Контроль версий с первого дня:** Делайте коммиты после каждого этапа
3. **Пишите тесты постепенно:** Не оставляйте тестирование на конец
4. **Сосредоточьтесь на основных RFC:** RFC 5280 — ваша библия; реализуйте то, что сможете
5. **Запрашивайте разъяснения:** Если требования неоднозначны, уточняйте
